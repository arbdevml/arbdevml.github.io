<!DOCTYPE html>
<html>
<head>
<title>X-vector (voice fingerprint) online</title>
<meta name="description" content="X-vector speaker recognition system for voice fingerprint identification">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
<script src="Vosklet.js" async defer></script>
  <script>
    // console output capture
    let consoleOutput = "";

    const originalLog = console.log;
    const originalInfo = console.info;
    const originalWarn = console.warn;
    const originalError = console.error;
    const originalDebug = console.debug;

    // Add pause/resume functionality
    let isPaused = false;
    let isStarted = false;

    function toggleStartPause() {
      const startBtn = document.getElementById('start-btn');

      if (!isStarted) {
        // Start the system
        isStarted = true;
        isPaused = false;
        if (startBtn) {
          startBtn.textContent = "Pause";
        }
        start();
      } else if (!isPaused) {
        // Pause the system
        isPaused = true;
        if (startBtn) {
          startBtn.textContent = "Resume";
        }

        // Disconnect audio processing
        if (transferer && micNode) {
          try {
            micNode.disconnect(transferer);
            console.log("System paused - Audio processing stopped");
          } catch (error) {
            console.warn("Error during pause:", error);
          }
        }

        const status = document.getElementById('status');
        if (status) {
          status.textContent = "System paused";
          status.style.backgroundColor = "#fff3cd";
        }

        console.info("System paused");
      } else {
        // Resume the system
        isPaused = false;
        if (startBtn) {
          startBtn.textContent = "Pause";
        }

        // Reconnect audio processing
        if (transferer && micNode && recognizer) {
          try {
            micNode.connect(transferer);
            console.log("System resumed - Audio processing restarted");
          } catch (error) {
            console.warn("Error during resume:", error);
          }
        }

        const status = document.getElementById('status');
        if (status) {
          status.textContent = "System ready - Listening for speech input";
          status.style.backgroundColor = "#e8f5e8";
        }

        console.info("System resumed");
      }
    }

    function formatMessage(level, ...args) {
      const timestamp = new Date().toISOString();
      return `[${timestamp}] ${level}: ${args.join(' ')}\n`;
    }

    console.log = function(...args) {
      const formattedMessage = formatMessage('LOG', ...args);
      consoleOutput += formattedMessage;
      updateConsoleDisplay();
      originalLog.apply(console, args);
    };

    console.info = function(...args) {
      const formattedMessage = formatMessage('INFO', ...args);
      consoleOutput += formattedMessage;
      updateConsoleDisplay();
      originalInfo.apply(console, args);
    };

    console.warn = function(...args) {
      const formattedMessage = formatMessage('WARN', ...args);
      consoleOutput += formattedMessage;
      updateConsoleDisplay();
      originalWarn.apply(console, args);
    };

    console.error = function(...args) {
      const formattedMessage = formatMessage('ERROR', ...args);
      consoleOutput += formattedMessage;
      updateConsoleDisplay();
      originalError.apply(console, args);
    };

    console.debug = function(...args) {
      const formattedMessage = formatMessage('DEBUG', ...args);
      consoleOutput += formattedMessage;
      updateConsoleDisplay();
      originalDebug.apply(console, args);
    };

    function updateConsoleDisplay() {
      const outputDiv = document.getElementById('console-output');
      if (outputDiv) {
        outputDiv.textContent = consoleOutput;
        outputDiv.scrollTop = outputDiv.scrollHeight;
      }
    }

    //  global state tracking
    let audioContext, micNode, recognizer, transferer, module;
    let isFirstLoad = true;
    let currentRetryCount = 0;
    const maxRetries = 3;

    // Timeout utility function
    function withTimeout(promise, timeoutMs = 10000) {
      return Promise.race([
        promise,
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
        )
      ]);
    }

    // Retry utility function
    async function withRetry(operation, maxRetries = 3, delay = 1000) {
      let lastError;

      for (let i = 0; i <= maxRetries; i++) {
        try {
          return await operation();
        } catch (error) {
          lastError = error;
          console.warn(`Attempt ${i + 1} failed:`, error.message);

          if (i < maxRetries) {
            console.info(`Retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2; // Exponential backoff
          }
        }
      }

      throw lastError;
    }

    // Progress indicator utility
    function updateProgress(message, progress = 0) {
      const progressBar = document.getElementById('progress-bar');
      if (progressBar) {
        progressBar.textContent = `${message} (${Math.round(progress * 100)}%)`;
      }
      console.log(`${message} - ${Math.round(progress * 100)}%`);
    }

    // start function with all improvements
    async function start() {
      try {
        console.info("Starting X-vector speaker recognition system...");

        // Reset retry counter
        currentRetryCount = 0;

        // Clear previous output
        consoleOutput = "";
        updateConsoleDisplay();

        // Show progress indicator
        const progressBar = document.getElementById('progress-bar');
        if (progressBar) {
          progressBar.textContent = "Initializing system...";
        }

        try {
          updateProgress("Loading Vosklet library", 0.1);

          updateProgress("Vosklet library loaded", 0.2);

          // Create audio context with timeout
          console.log("Creating AudioContext...");
          updateProgress("Setting up audio context", 0.3);

          const ctxPromise = new Promise((resolve, reject) => {
            try {
              audioContext = new AudioContext({ sinkId: { type: "none" } });
              console.log("AudioContext created successfully");
              resolve(audioContext);
            } catch (error) {
              console.error("Failed to create AudioContext:", error);
              reject(error);
            }
          });

          audioContext = await withTimeout(ctxPromise, 5000);
          updateProgress("Audio context ready", 0.4);

          // Setup microphone with timeout and retry
          console.log("Requesting microphone access...");
          updateProgress("Requesting microphone access", 0.5);

          const micPromise = new Promise((resolve, reject) => {
            navigator.mediaDevices.getUserMedia({
              video: false,
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                channelCount: 1
              },
            }).then(stream => {
              console.log("Microphone access granted and source created");
              micNode = audioContext.createMediaStreamSource(stream);
              resolve(micNode);
            }).catch(error => {
              console.error("Microphone access denied:", error);
              reject(error);
            });
          });

          micNode = await withTimeout(
            withRetry(() => micPromise, maxRetries),
            10000
          );
          updateProgress("Microphone ready", 0.6);

          // Load Vosklet module with timeout and retry
          console.log("Loading Vosklet module...");
          updateProgress("Loading Vosklet module", 0.7);

          const moduleLoadPromise = new Promise((resolve, reject) => {
            try {
              if (typeof window.loadVosklet === 'undefined') {
                throw new Error("loadVosklet function not available");
              }
              resolve(window.loadVosklet());
            } catch (error) {
              reject(error);
            }
          });

          module = await withTimeout(
            withRetry(() => moduleLoadPromise, maxRetries),
            20000
          );
          console.log("Vosklet module loaded successfully");
          updateProgress("Module loaded", 0.8);

          // Set log level to see more details (optional)
          module.setLogLevel(5);
          console.info("Log level set to verbose");

          // Load base model with progress tracking and timeout
          console.log("Loading base model: vosk-model-small-en-us-0.15.tar.gz");
          updateProgress("Loading base speech recognition model", 0.9);

          const baseModelPromise = new Promise((resolve, reject) => {
            try {
              const model = module.createModel(
                "https://ccoreilly.github.io/vosk-browser/models/vosk-model-small-en-us-0.15.tar.gz",
                "English",
                "vosk-model-small-en-us-0.15"
              );
              resolve(model);
            } catch (error) {
              reject(error);
            }
          });

          const baseModel = await withTimeout(
            withRetry(() => baseModelPromise, maxRetries),
            30000
          );
          console.log("Base model loaded successfully");
          updateProgress("Base model loaded", 0.95);

          // Load speaker model with timeout and retry
          console.log("Loading speaker model: vosk-model-spk-0.4.tar.gz");
          updateProgress("Loading speaker recognition model", 0.96);

          const spkModelPromise = new Promise((resolve, reject) => {
            try {
              const spkModel = module.createSpkModel(
                "vosk-model-spk-0.4.tar.gz",
                "Speaker",
                "vosk-model-spk-0.4"
              );
              resolve(spkModel);
            } catch (error) {
              reject(error);
            }
          });

          const spkModel = await withTimeout(
            withRetry(() => spkModelPromise, maxRetries),
            30000
          );
          console.log("Speaker model loaded successfully");
          updateProgress("Speaker model loaded", 0.97);

          // Create recognizer with speaker model
          console.log("Creating recognizer with speaker model...");
          const recognizerPromise = new Promise((resolve, reject) => {
            try {
              const rec = module.createRecognizerWithSpkModel(baseModel, audioContext.sampleRate, spkModel);
              resolve(rec);
            } catch (error) {
              reject(error);
            }
          });

          recognizer = await withTimeout(recognizerPromise, 10000);
          console.log("Recognizer created successfully");
          updateProgress("Recognizer created", 0.98);

          // Listen for results
          recognizer.addEventListener("result", ev => {
            console.log("Final recognition result:", ev.detail);
          });

          recognizer.addEventListener("partialResult", ev => {
            console.log("Partial recognition result:", ev.detail);
          });

          // Create transferer node with timeout
          console.log("Creating transferer node...");
          const transfererPromise = new Promise((resolve, reject) => {
            try {
              const tr = module.createTransferer(audioContext, 128 * 150);
              resolve(tr);
            } catch (error) {
              reject(error);
            }
          });

          transferer = await withTimeout(transfererPromise, 10000);
          console.log("Transferer node created successfully");
          updateProgress("Transferer ready", 0.99);

          // Connect audio data to recognizer
          console.log("Connecting microphone to recognizer...");
          transferer.port.onmessage = ev => recognizer.acceptWaveform(ev.data);
          micNode.connect(transferer);

          console.info("X-vector speaker recognition started successfully!");
          console.log("System is now listening for speech input...");
          updateProgress("System ready", 1.0);

          // Show completion message
          setTimeout(() => {
            const status = document.getElementById('status');
            if (status) {
              status.textContent = "System ready - Listening for speech input";
            }
          }, 1000);

        } catch (error) {
          console.error("Fatal error in start function:", error);
          console.error("Error name:", error.name);
          console.error("Error message:", error.message);
          console.error("Error stack:", error.stack);

          // Show error status
          const status = document.getElementById('status');
          if (status) {
            status.textContent = "Error occurred - Check console for details";
          }
        }
      } catch (error) {
        console.error("Unexpected error in start function:", error);
      }
    }

    // Add a function to clear the console
    function clearConsole() {
      consoleOutput = "";
      updateConsoleDisplay();
    }

    // Add copy to clipboard functionality
    function copyToClipboard() {
      const outputDiv = document.getElementById('console-output');
      if (outputDiv) {
        const text = outputDiv.textContent;
        navigator.clipboard.writeText(text).then(() => {
          console.log("Console output copied to clipboard!");
          // Show temporary feedback
          const originalText = document.getElementById('copy-btn').textContent;
          document.getElementById('copy-btn').textContent = "Copied!";
          setTimeout(() => {
            document.getElementById('copy-btn').textContent = originalText;
          }, 2000);
        }).catch(err => {
          console.error("Failed to copy: ", err);
        });
      }
    }

    // Add scroll to bottom functionality
    function scrollToBottom() {
      const outputDiv = document.getElementById('console-output');
      if (outputDiv) {
        outputDiv.scrollTop = outputDiv.scrollHeight;
      }
    }
  </script>

  <style>
    #console-output {
      width: 90%;
      height: 300px;
      border: 1px solid #ccc;
      padding: 10px;
      margin: 20px auto;
      overflow-y: auto;
      background-color: #f5f5f5;
      font-family: monospace;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    button {
      display: inline-block;
      margin: 10px 5px;
      padding: 10px 20px;
      font-size: 16px;
    }

    .controls {
      text-align: center;
      margin-bottom: 10px;
    }

    .control-btn {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 16px;
      cursor: pointer;
      border-radius: 4px;
    }

    .control-btn:hover {
      background-color: #45a049;
    }

    .clear-btn {
      background-color: #ff6b6b;
      color: white;
      border: none;
      padding: 10px 16px;
      cursor: pointer;
      border-radius: 4px;
    }

    .clear-btn:hover {
      background-color: #ff5252;
    }

    #copy-btn {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 10px 16px;
      cursor: pointer;
      border-radius: 4px;
    }

    #copy-btn:hover {
      background-color: #0b7dda;
    }

    #progress-bar {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background-color: #e8f5e8;
      border-radius: 4px;
      font-weight: bold;
    }

    #status {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background-color: #fff3cd;
      border-radius: 4px;
      color: #856404;
      font-weight: bold;
    }
  </style>
</head>
<body>
<a class="github-fork-ribbon" href="https://github.com/arbdevml/arbdevml.github.io" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
<h1 style="text-align: center;">X-vector (voice fingerprint) online</h1>
<p style="text-align: center;">Real-time speaker recognition system using Vosk library</p>

  <div class="controls">
    <button id="start-btn" class="control-btn" onclick="toggleStartPause()">Start Speaker Recognition</button>
    <button class="clear-btn" onclick="clearConsole()">Clear Console</button>
    <button id="copy-btn" class="control-btn" onclick="copyToClipboard()">Copy to Clipboard</button>
  </div>

  <div id="progress-bar">
    System not initialized
  </div>

  <div id="status">
    Ready to start system
  </div>

  <div id="console-output">
    Console output will appear here...
  </div>
  <div style="text-align: center; margin-top: 20px; padding: 10px; font-size: 14px; color: #666;">
  <p>Powered by</p>
  <p>
    <a href="https://github.com/msqr1/Vosklet/" target="_blank">https://github.com/msqr1/Vosklet/</a> | 
    <a href="https://github.com/alphacep/vosk-api/" target="_blank">https://github.com/alphacep/vosk-api/</a>
  </p>
  <a href="https://stand-with-ukraine.pp.ua/" class="em-ribbon" style="position: fixed; left:0; top:0; width: 90px; height: 90px; background: url('http://stfalcon.github.io/stopwar/img/stop-war-in-ukraine.png'); z-index: 10000; border: 0;" title="Do something to stop this war! Russians are killing our children and civilians!" target="_blank"></a>
</div>
</body>
</html>
